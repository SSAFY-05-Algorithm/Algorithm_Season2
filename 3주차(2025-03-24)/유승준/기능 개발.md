# [level 2] 기능개발 - 42586 

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/42586) 

### 성능 요약

메모리: 72.5 MB, 시간: 0.10 ms

### 구분

코딩테스트 연습 > 스택／큐

### 채점결과

정확성: 100.0<br/>합계: 100.0 / 100.0

### 제출 일자

2025년 03월 24일 19:28:48

### 문제 설명

<p>프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.</p>

<p>또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.</p>

<p>먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.</p>

<h5>제한 사항</h5>

<ul>
<li>작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.</li>
<li>작업 진도는 100 미만의 자연수입니다.</li>
<li>작업 속도는 100 이하의 자연수입니다.</li>
<li>배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.</li>
</ul>

<h5>입출력 예</h5>
<table class="table">
        <thead><tr>
<th>progresses</th>
<th>speeds</th>
<th>return</th>
</tr>
</thead>
        <tbody><tr>
<td>[93, 30, 55]</td>
<td>[1, 30, 5]</td>
<td>[2, 1]</td>
</tr>
<tr>
<td>[95, 90, 99, 99, 80, 99]</td>
<td>[1, 1, 1, 1, 1, 1]</td>
<td>[1, 3, 2]</td>
</tr>
</tbody>
      </table>
<h5>입출력 예 설명</h5>

<p>입출력 예 #1<br>
첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.<br>
두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다. 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다.<br>
세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다. </p>

<p>따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다.</p>

<p>입출력 예 #2<br>
모든 기능이 하루에 1%씩 작업이 가능하므로, 작업이 끝나기까지 남은 일수는 각각 5일, 10일, 1일, 1일, 20일, 1일입니다. 어떤 기능이 먼저 완성되었더라도 앞에 있는 모든 기능이 완성되지 않으면 배포가 불가능합니다.</p>

<p>따라서 5일째에 1개의 기능, 10일째에 3개의 기능, 20일째에 2개의 기능이 배포됩니다.</p>

<p>※ 공지 - 2020년 7월 14일 테스트케이스가 추가되었습니다.</p>

## 문제 분석
각 기능마다 소요시간을 계산하고, 우선순위에 따라서 기능이 배포되는 시점에 몇 개의 기능을 배포할 수 있을지 구한다. 소요시간이 저장된 배열을 탐색하면서 현재 소요시간과 최대 소요시간을 비교하여 현재 소요시간이 클 경우, 이전 기능이 배포된 이후에 배포가 가능하므로 새로운 배포시점(1)을 추가한다. 최대 소요시간이 더 클 경우, 이전 기능과 함께 배포될 수 있으므로 현재 배포시점의 기능 개수에 1을 더해준다.

## 코드
```java
import java.util.*;

class Solution {
    public List<Integer> solution(int[] progresses, int[] speeds) {
        int len = progresses.length;
        int[] days = new int[len];
        
        for (int i=0; i<len; i++) {
            int day = (100-progresses[i]) / speeds[i];
            int rem = (100-progresses[i]) % speeds[i];
            days[i] = rem == 0 ? day : day+1;
        }
        
        int maxDay = Integer.MIN_VALUE;
        List<Integer> answer = new ArrayList<>();
        for (int day : days) {
            if (day > maxDay) {
                maxDay = day;
                answer.add(1);
            }
            else {
                int num = answer.get(answer.size()-1)+1;
                answer.set(answer.size()-1, num);
            }
        }
        return answer;
    }

}
```
## 시간 복잡도
O(N<sup>2</sup>)

## 느낀점
처음에 소요시간을 구하는 과정에서 while문과 for문으로 각 기능에 맞는 속도를 다 더해주는 방식을 구현했다가 뭔가 비효율적인 코드라는 것을 느꼈다. 그래서 남은 작업량에 소요시간을 나눈 몫과 나머지 연산을 활용하는 방식으로 약 0.7ms의 시간을 줄일 수 있었다!