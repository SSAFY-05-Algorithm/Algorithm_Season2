## BOJ 가장 긴 감소하는 부분 수열

(https://www.acmicpc.net/problem/11722)

### 문제분석

1. 수열 A 가 주어졌을 때, 수열을 수정하지 않고, 가장 긴 감소하는 부분 수열을 구하고 그 길이를 출력한다.

### 문제조건

1. 1 <= 수열의 크기 <= 1,000
2. 1 <= 수열의 원소 <= 1,000

### 아이디어

1. 수열과 동일한 배열을 하나 만든다. 해당 수열은 동일한 인덱스의 수열로 끝나는 경우, 만들어지는 가장 긴 감소하는 부분 수열의 길이이다. 기본 값은 1로 초기화 한다.
2. 수열을 순차적으로 탐색하며(i), 해당 수열에서 앞 수열을 탐색해(j) arr[j] > arr[i] 라면 MAX(cache[i], cache[j]) 를 cache[i]에 저장한다.
3. cache를 업데이트 하는 과정에서 가장 큰 값을 저장해 놨다가 출력한다.

### 시간복잡도

1. O(N^2) || O(N + N/2)

### 회고

1. 처음에 문제를 잘못 이해했습니다. 주어진 수열을 수정하지 않고 가장 긴 감소하는 부분 수열 을 구하는 문제였으나, 주어진 수열 전체에서 가장 긴 감소하는 부분 수열을 구하는 문제인 줄 알고, TreeSet을 통해 접근 했다가 틀렸습니다.

### Code

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

/*
 * 흠... 트리셋이면 될 줄 알았는데. 어떻게 바로 틀렸습니다가 나오지?
 * 문제 이해를 잘못한건가?
 * 주어진 수열의 위치를 고정하고 부분 수열을 뽑아 내는 문제인가보다.
 * 내 위치의 제일 긴 감소하는 부분수열의 길이는 기본적으로 1이고
 * 내 이전을 봤을 때 내 이전보다 내가 작다면 +1 한 값이 될 수 있다.
 */

public class boj11722 {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int numOfNumber = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());

        int[] arr = new int[numOfNumber];
        int[] dp = new int[numOfNumber];

        for (int i = 0; i < numOfNumber; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
            dp[i] = 1;
        }

        int maxLength = 1;
        for (int i = 1; i < numOfNumber; i++) {
            for (int j = 0; j < i; j++) {
                if (arr[i] < arr[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            maxLength = Math.max(maxLength, dp[i]);
        }
        System.out.println(maxLength);
    }
}
```
